<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EchoMemo</title>
    
    <!-- PWA Manifest -->
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#374151">
    <link rel="apple-touch-icon" href="EchoMemo192.png">

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- WaveSurfer.js for audio visualization and trimming -->
    <script src="https://unpkg.com/wavesurfer.js@7"></script>
    <script src="https://unpkg.com/wavesurfer.js@7/dist/plugins/regions.min.js"></script>

    <style>
        /* Custom styles for a cleaner look and feel */
        body {
            font-family: 'Inter', sans-serif;
            overscroll-behavior: none;
        }
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
        
        /* Simple transition for view switching */
        .view {
            display: none;
            animation: fadeIn 0.3s ease-in-out;
        }
        .view.active {
            display: flex;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: scale(0.98); }
            to { opacity: 1; transform: scale(1); }
        }

        /* Styling for the audio recording indicator */
        .recording-dot {
            animation: pulse 1.5s infinite;
        }
        @keyframes pulse {
            0% { transform: scale(0.95); box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7); }
            70% { transform: scale(1); box-shadow: 0 0 0 10px rgba(239, 68, 68, 0); }
            100% { transform: scale(0.95); box-shadow: 0 0 0 0 rgba(239, 68, 68, 0); }
        }

        /* Custom scrollbar */
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #1f2937; }
        ::-webkit-scrollbar-thumb { background: #4b5563; border-radius: 10px; }
        ::-webkit-scrollbar-thumb:hover { background: #6b7280; }

        /* Custom styles for WaveSurfer region handles */
        .wavesurfer-region:hover {
            background-color: rgba(255, 255, 255, 0.25) !important;
        }
        .wavesurfer-region::before,
        .wavesurfer-region::after {
            content: '';
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            width: 8px;
            height: 24px;
            background-color: white;
            border-radius: 4px;
            cursor: col-resize;
            z-index: 10;
        }
        .wavesurfer-region::before {
            left: 2px;
        }
        .wavesurfer-region::after {
            right: 2px;
        }
    </style>
</head>
<body class="bg-gray-900 text-white antialiased">

    <div id="app-container" class="max-w-lg mx-auto h-screen flex flex-col pb-4">

        <!-- ===== Main List View ===== -->
        <div id="view-list" class="view flex-col h-full w-full p-4 active">
            <header class="flex items-center justify-between pb-4 border-b border-gray-700">
                <h1 class="text-2xl font-bold text-gray-100">EchoMemo</h1>
                <div class="flex items-center gap-2">
                    <button id="open-playlist-btn" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-lg transition-colors flex items-center gap-2">
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15V6"></path><path d="M18.5 18a2.5 2.5 0 1 0 0-5 2.5 2.5 0 0 0 0 5Z"></path><path d="M12 12H3"></path><path d="M16 6H3"></path><path d="M12 18H3"></path></svg>
                        Playlist
                    </button>
                    <button id="install-button" class="hidden bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-lg transition-colors">Install App</button>
                </div>
            </header>
            <div id="storage-info" class="py-4 text-sm text-gray-400" style="display: none;">
                Total storage: <span id="total-storage" class="font-semibold text-gray-300">0 B</span>
            </div>
            <div id="recordings-list" class="flex-grow overflow-y-auto pb-4 space-y-3" style="display: none;">
                <!-- Recordings will be populated here by JavaScript -->
            </div>
            <div id="empty-state-container" class="flex-grow flex items-center justify-center">
                 <p id="empty-state" class="text-gray-400 text-center">No memos yet. Tap 'Record New' to start!</p>
            </div>
            <footer class="pt-4">
                <button id="record-new-btn" class="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-4 px-4 rounded-lg flex items-center justify-center gap-2 transition-transform duration-200 active:scale-95">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 2a3 3 0 0 0-3 3v7a3 3 0 0 0 6 0V5a3 3 0 0 0-3-3Z"></path><path d="M19 10v2a7 7 0 0 1-14 0v-2"></path><line x1="12" x2="12" y1="19" y2="22"></line></svg>
                    Record New Memo
                </button>
            </footer>
        </div>

        <!-- ===== Recording View ===== -->
        <div id="view-record" class="view flex-col h-full w-full p-4">
            <header class="p-4 flex-shrink-0 flex items-center justify-between">
                 <button id="cancel-record-btn" class="p-2 rounded-full hover:bg-gray-700">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="19" y1="12" x2="5" y2="12"></line><polyline points="12 19 5 12 12 5"></polyline></svg>
                </button>
                <h2 id="record-view-title" class="text-xl font-semibold text-center text-gray-300">Prepare Memo</h2>
                <div class="w-8"></div> <!-- Spacer -->
            </header>

            <div class="flex-grow flex flex-col items-center text-center min-h-0">
                <!-- This will be shown during recording -->
                <div id="recording-display" class="hidden w-full flex-shrink-0 text-center p-4">
                    <div class="recording-dot w-12 h-12 bg-red-500 rounded-full flex items-center justify-center mb-2 mx-auto">
                        <svg xmlns="http://www.w3.org/2000/svg" class="w-6 h-6 text-white" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 2a3 3 0 0 0-3 3v7a3 3 0 0 0 6 0V5a3 3 0 0 0-3-3Z"></path><path d="M19 10v2a7 7 0 0 1-14 0v-2"></path><line x1="12" x2="12" y1="19" y2="22"></line></svg>
                    </div>
                    <p id="recording-timer" class="text-2xl font-mono">00:00.0</p>
                </div>

                <!-- Script area, always visible in this view -->
                <div id="script-display" class="w-full h-full flex flex-col">
                    <textarea id="script-textarea" class="w-full flex-grow bg-gray-800 text-white rounded-md p-3 border border-gray-700 focus:ring-2 focus:ring-indigo-500 focus:outline-none" placeholder="Paste your script here..."></textarea>
                </div>
            </div>
            
            <footer class="pt-4 flex-shrink-0">
                <button id="start-recording-btn" class="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-4 px-4 rounded-lg flex items-center justify-center gap-2 transition-transform duration-200 active:scale-95">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><circle cx="12" cy="12" r="3"></circle></svg>
                    Start Recording
                </button>
                <button id="stop-recording-btn" class="w-full bg-red-600 hover:bg-red-700 text-white font-bold py-4 px-4 rounded-lg hidden transition-transform duration-200 active:scale-95">Stop Recording</button>
            </footer>
        </div>

        <!-- ===== Trim View ===== -->
        <div id="view-trim" class="view flex-col h-full w-full">
            <header class="p-4 flex-shrink-0">
                <h2 class="text-xl font-semibold text-center text-gray-300">Trim Your Memo</h2>
                <p class="text-center text-gray-400 text-sm">Drag the edges of the audio waveform to select the part you want to keep.</p>
            </header>
            <div class="flex-grow p-4 px-8 min-h-0">
                <div id="waveform" class="w-full h-full bg-gray-800 rounded-lg"></div>
            </div>
            <footer class="p-4 flex-shrink-0 flex gap-4">
                <button id="cancel-trim-btn" class="flex-1 bg-gray-700 hover:bg-gray-600 text-white font-bold py-3 px-4 rounded-lg transition-colors">Cancel</button>
                <button id="play-pause-trim-btn" class="bg-green-600 hover:bg-green-700 text-white font-bold p-3 rounded-lg transition-colors flex items-center justify-center">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="5 3 19 12 5 21 5 3"></polygon></svg>
                </button>
                <button id="save-trim-btn" class="flex-1 bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-4 rounded-lg transition-colors">Save</button>
            </footer>
        </div>

        <!-- ===== Playlist View ===== -->
        <div id="view-playlist" class="view flex-col h-full w-full p-4">
            <header class="flex items-center justify-between pb-4 border-b border-gray-700">
                <button id="back-from-playlist-btn" class="p-2 rounded-full hover:bg-gray-700">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="19" y1="12" x2="5" y2="12"></line><polyline points="12 19 5 12 12 5"></polyline></svg>
                </button>
                <h2 class="text-xl font-semibold text-center flex-grow">Create Playlist</h2>
                <div class="w-10"></div>
            </header>
            
            <div class="py-4 flex items-center justify-between gap-3">
                <button id="select-all-btn" class="bg-gray-700 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded-lg transition-colors">Select All</button>
                <div class="flex items-center gap-3">
                    <label class="text-sm text-gray-300">Default Repeats:</label>
                    <input type="number" id="default-repeats-input" class="bg-gray-800 text-white rounded-md px-3 py-2 w-20 border border-gray-700 focus:ring-2 focus:ring-indigo-500 focus:outline-none" value="3" min="1" max="99">
                </div>
            </div>
            
            <div id="playlist-items-container" class="flex-grow overflow-y-auto pb-4 space-y-2">
                <!-- Playlist items will be populated here -->
            </div>
            
            <div id="playlist-empty-state" class="flex-grow flex items-center justify-center">
                <p class="text-gray-400 text-center">No memos available. Record some memos first!</p>
            </div>
            
            <footer class="pt-4">
                <button id="start-playlist-btn" class="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-4 rounded-lg transition-colors disabled:bg-gray-700 disabled:cursor-not-allowed" disabled>Start Playlist</button>
            </footer>
        </div>

        <!-- ===== Playlist Playback View ===== -->
        <div id="view-playlist-playback" class="view flex-col h-full w-full p-4">
            <header class="flex items-center pb-4 flex-shrink-0">
                <button id="stop-playlist-btn" class="p-2 rounded-full hover:bg-gray-700">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="19" y1="12" x2="5" y2="12"></line><polyline points="12 19 5 12 12 5"></polyline></svg>
                </button>
                <h2 class="text-xl font-semibold text-center flex-grow px-4">Playlist</h2>
                <div class="w-10"></div>
            </header>
            
            <div class="flex-grow flex flex-col items-center justify-center text-center">
                <div class="bg-gray-800 p-8 rounded-full mb-8">
                    <svg xmlns="http://www.w3.org/2000/svg" class="w-16 h-16 text-indigo-400" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><polyline points="10 8 16 12 10 16 10 8"></polyline></svg>
                </div>
                
                <h3 id="playlist-current-title" class="text-2xl font-semibold mb-2 px-4">Memo Title</h3>
                <p id="playlist-progress-text" class="text-gray-400 mb-6">Entry 1 of 5 • Repeat 1 of 3</p>
                
                <div class="w-full max-w-sm">
                    <div class="flex justify-between text-xs text-gray-400 font-mono mb-2">
                        <span id="playlist-current-time">0:00</span>
                        <span id="playlist-total-time">0:00</span>
                    </div>
                    <input type="range" id="playlist-seek-bar" class="w-full" value="0" step="0.1">
                </div>
            </div>
            
            <footer class="pt-4 flex justify-center">
                <button id="playlist-play-pause-btn" class="w-16 h-16 bg-indigo-600 rounded-full flex items-center justify-center text-white transition-transform duration-200 active:scale-90">
                    <!-- Play/Pause icon will be set by JS -->
                </button>
            </footer>
            
            <audio id="playlist-audio-player"></audio>
        </div>

        <!-- ===== Playback View ===== -->
        <div id="view-play" class="view flex-col h-full w-full p-4">
            <header class="flex items-center pb-4 flex-shrink-0">
                <button id="back-to-list-btn" class="p-2 rounded-full hover:bg-gray-700">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="19" y1="12" x2="5" y2="12"></line><polyline points="12 19 5 12 12 5"></polyline></svg>
                </button>
                <h2 id="playback-title" class="text-xl font-semibold text-center flex-grow truncate px-4">Playing Memo</h2>
            </header>
            <div class="flex-grow flex flex-col items-center justify-center text-center">
                <div class="bg-gray-800 p-8 rounded-full mb-8">
                    <svg xmlns="http://www.w3.org/2000/svg" class="w-16 h-16 text-indigo-400" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 18v-6a9 9 0 0 1 18 0v6"></path><path d="M21 19a2 2 0 0 1-2 2h-1a2 2 0 0 1-2-2v-3a2 2 0 0 1 2-2h3zM3 19a2 2 0 0 0 2 2h1a2 2 0 0 0 2-2v-3a2 2 0 0 0-2-2H3z"></path></svg>
                </div>
                <div class="w-full max-w-sm">
                    <div class="flex justify-between text-xs text-gray-400 font-mono mb-2">
                        <span id="current-time">0:00</span>
                        <span id="total-time">0:00</span>
                    </div>
                    <input type="range" id="seek-bar" class="w-full" value="0" step="0.1">
                </div>
                <div class="flex items-center gap-6 mt-6">
                    <button id="play-pause-btn" class="w-16 h-16 bg-indigo-600 rounded-full flex items-center justify-center text-white transition-transform duration-200 active:scale-90">
                        <!-- Play/Pause icon will be set by JS -->
                    </button>
                </div>
            </div>
            <audio id="audio-player" loop></audio>
        </div>

    </div>
    
    <!-- ===== Save Modal ===== -->
    <div id="save-modal" class="fixed inset-0 bg-black bg-opacity-70 hidden items-center justify-center p-4">
        <div class="bg-gray-800 rounded-lg p-6 w-full max-w-sm">
            <h3 class="text-lg font-medium mb-4">Save Memo</h3>
            <input type="text" id="memo-name-input" class="w-full bg-gray-700 text-white rounded-md p-2 mb-4 border border-gray-600 focus:ring-2 focus:ring-indigo-500 focus:outline-none" placeholder="Enter a name...">
            <div class="flex justify-end gap-3">
                <button id="cancel-save-btn" class="bg-gray-600 hover:bg-gray-500 text-white font-bold py-2 px-4 rounded-lg transition-colors">Cancel</button>
                <button id="confirm-save-btn" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-lg transition-colors">Save</button>
            </div>
        </div>
    </div>

    <!-- ===== Rename Modal ===== -->
    <div id="rename-modal" class="fixed inset-0 bg-black bg-opacity-70 hidden items-center justify-center p-4">
        <div class="bg-gray-800 rounded-lg p-6 w-full max-w-sm">
            <h3 class="text-lg font-medium mb-4">Rename Memo</h3>
            <input type="text" id="rename-memo-name-input" class="w-full bg-gray-700 text-white rounded-md p-2 mb-4 border border-gray-600 focus:ring-2 focus:ring-indigo-500 focus:outline-none" placeholder="Enter a new name...">
            <div class="flex justify-end gap-3">
                <button id="cancel-rename-btn" class="bg-gray-600 hover:bg-gray-500 text-white font-bold py-2 px-4 rounded-lg transition-colors">Cancel</button>
                <button id="confirm-rename-btn" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-lg transition-colors">Rename</button>
            </div>
        </div>
    </div>

    <!-- ===== Delete Confirmation Modal ===== -->
    <div id="delete-modal" class="fixed inset-0 bg-black bg-opacity-70 hidden items-center justify-center p-4">
        <div class="bg-gray-800 rounded-lg p-6 w-full max-w-sm">
            <h3 class="text-lg font-medium mb-2">Delete Memo</h3>
            <p class="text-gray-400 mb-4">Are you sure you want to delete this memo? This action cannot be undone.</p>
            <div class="flex justify-end gap-3">
                <button id="cancel-delete-btn" class="bg-gray-600 hover:bg-gray-500 text-white font-bold py-2 px-4 rounded-lg transition-colors">Cancel</button>
                <button id="confirm-delete-btn" class="bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-lg transition-colors">Delete</button>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {

            // --- Globals & State ---
            const DB_NAME = 'EchoMemoDB';
            const DB_VERSION = 1;
            const STORE_NAME = 'recordings';
            let db;

            let mediaRecorder;
            let recordedChunks = [];
            let recordingTimerInterval;
            let recordingStartTime;
            
            let tempAudioBlob = null;
            let wavesurfer = null;
            let trimRegion = null;
            let isTrimPlaying = false;
            
            let currentPlayingAudio = null;
            let currentPlayingInfo = null;
            let recordingToDeleteId = null; // To store the ID of the memo to be deleted
            let recordingToRenameId = null; // To store the ID of the memo to be renamed
            
            // --- UI Elements ---
            const views = {
                list: document.getElementById('view-list'),
                record: document.getElementById('view-record'),
                trim: document.getElementById('view-trim'),
                play: document.getElementById('view-play'),
                playlist: document.getElementById('view-playlist'),
                playlistPlayback: document.getElementById('view-playlist-playback'),
            };
            const recordNewBtn = document.getElementById('record-new-btn');
            const stopRecordingBtn = document.getElementById('stop-recording-btn');
            const recordingTimerEl = document.getElementById('recording-timer');
            const recordingsListEl = document.getElementById('recordings-list');
            const waveformEl = document.getElementById('waveform');
            const saveTrimBtn = document.getElementById('save-trim-btn');
            const cancelTrimBtn = document.getElementById('cancel-trim-btn');
            const playPauseTrimBtn = document.getElementById('play-pause-trim-btn');
            const saveModal = document.getElementById('save-modal');
            const memoNameInput = document.getElementById('memo-name-input');
            const confirmSaveBtn = document.getElementById('confirm-save-btn');
            const cancelSaveBtn = document.getElementById('cancel-save-btn');
            const deleteModal = document.getElementById('delete-modal');
            const confirmDeleteBtn = document.getElementById('confirm-delete-btn');
            const cancelDeleteBtn = document.getElementById('cancel-delete-btn');
            const renameModal = document.getElementById('rename-modal');
            const renameMemoNameInput = document.getElementById('rename-memo-name-input');
            const confirmRenameBtn = document.getElementById('confirm-rename-btn');
            const cancelRenameBtn = document.getElementById('cancel-rename-btn');
            const audioPlayer = document.getElementById('audio-player');
            const playbackTitle = document.getElementById('playback-title');
            const playPauseBtn = document.getElementById('play-pause-btn');
            const seekBar = document.getElementById('seek-bar');
            const currentTimeEl = document.getElementById('current-time');
            const totalTimeEl = document.getElementById('total-time');
            const backToListBtn = document.getElementById('back-to-list-btn');
            
            // Recording View elements
            const startRecordingBtn = document.getElementById('start-recording-btn');
            const cancelRecordBtn = document.getElementById('cancel-record-btn');
            const recordViewTitle = document.getElementById('record-view-title');
            const recordingDisplay = document.getElementById('recording-display');
            const scriptTextarea = document.getElementById('script-textarea');
            
            // Playlist View elements
            const openPlaylistBtn = document.getElementById('open-playlist-btn');
            const backFromPlaylistBtn = document.getElementById('back-from-playlist-btn');
            const defaultRepeatsInput = document.getElementById('default-repeats-input');
            const playlistItemsContainer = document.getElementById('playlist-items-container');
            const playlistEmptyState = document.getElementById('playlist-empty-state');
            const selectAllBtn = document.getElementById('select-all-btn');
            const startPlaylistBtn = document.getElementById('start-playlist-btn');
            
            // Playlist Playback View elements
            const stopPlaylistBtn = document.getElementById('stop-playlist-btn');
            const playlistCurrentTitle = document.getElementById('playlist-current-title');
            const playlistProgressText = document.getElementById('playlist-progress-text');
            const playlistCurrentTime = document.getElementById('playlist-current-time');
            const playlistTotalTime = document.getElementById('playlist-total-time');
            const playlistSeekBar = document.getElementById('playlist-seek-bar');
            const playlistPlayPauseBtn = document.getElementById('playlist-play-pause-btn');
            const playlistAudioPlayer = document.getElementById('playlist-audio-player');
            
            // Playlist state
            let playlistItems = []; // Array of {id, name, repeats, blob}
            let currentPlaylistIndex = 0;
            let currentRepeatCount = 0;
            let isPlaylistPlaying = false;


            // --- View Management ---
            const showView = (viewId) => {
                Object.values(views).forEach(v => v.classList.remove('active'));
                views[viewId].classList.add('active');
            };

            // --- Database ---
            function initDB() {
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open(DB_NAME, DB_VERSION);

                    request.onerror = (event) => reject("Database error: " + event.target.errorCode);
                    
                    request.onsuccess = (event) => {
                        db = event.target.result;
                        resolve();
                    };

                    request.onupgradeneeded = (event) => {
                        let db = event.target.result;
                        if (!db.objectStoreNames.contains(STORE_NAME)) {
                            db.createObjectStore(STORE_NAME, { keyPath: 'id', autoIncrement: true });
                        }
                    };
                });
            }

            // --- Audio Recording ---
            function prepareRecordingView() {
                showView('record');
                recordViewTitle.textContent = 'Prepare Memo';
                recordingDisplay.classList.add('hidden');
                startRecordingBtn.classList.remove('hidden');
                stopRecordingBtn.classList.add('hidden');
                scriptTextarea.value = ''; // Clear previous script
                scriptTextarea.readOnly = false;
            }

            async function startRecording() {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    recordedChunks = [];

                    // Update UI for recording state
                    recordViewTitle.textContent = 'Recording...';
                    recordingDisplay.classList.remove('hidden');
                    startRecordingBtn.classList.add('hidden');
                    stopRecordingBtn.classList.remove('hidden');
                    scriptTextarea.readOnly = true; // Prevent editing while recording

                    // Find a supported MIME type
                    const mimeTypes = ['audio/mp4', 'audio/webm;codecs=opus', 'audio/webm'];
                    const supportedMimeType = mimeTypes.find(type => MediaRecorder.isTypeSupported(type));

                    if (!supportedMimeType) {
                        alert("No supported audio format found for recording.");
                        showView('list');
                        return;
                    }

                    mediaRecorder = new MediaRecorder(stream, { mimeType: supportedMimeType });
                    mediaRecorder.ondataavailable = event => recordedChunks.push(event.data);
                    
                    mediaRecorder.onstop = () => {
                        tempAudioBlob = new Blob(recordedChunks, { type: supportedMimeType });
                        stream.getTracks().forEach(track => track.stop());
                        clearInterval(recordingTimerInterval);
                        initTrimView();
                    };
                    
                    mediaRecorder.start();
                    recordingStartTime = Date.now();
                    recordingTimerInterval = setInterval(updateRecordingTimer, 100);

                } catch (err) {
                    console.error('Error accessing microphone:', err);
                    alert('Could not access the microphone. Please grant permission and try again.');
                    showView('list');
                }
            }

            function stopRecording() {
                if (mediaRecorder && mediaRecorder.state === 'recording') {
                    mediaRecorder.stop();
                }
            }

            function updateRecordingTimer() {
                const elapsed = Date.now() - recordingStartTime;
                const minutes = String(Math.floor((elapsed / 1000 / 60) % 60)).padStart(2, '0');
                const seconds = String(Math.floor((elapsed / 1000) % 60)).padStart(2, '0');
                const milliseconds = String(Math.floor((elapsed % 1000) / 100)).padStart(1, '0');
                recordingTimerEl.textContent = `${minutes}:${seconds}.${milliseconds}`;
            }

            // --- Trim View ---
            async function trimAudioBlob(blob, startTime, endTime) {
                // Create an AudioContext to decode and process the audio
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                // Convert blob to ArrayBuffer
                const arrayBuffer = await blob.arrayBuffer();
                
                // Decode the audio data
                const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                
                // Calculate the sample range to extract
                const sampleRate = audioBuffer.sampleRate;
                const startSample = Math.floor(startTime * sampleRate);
                const endSample = Math.floor(endTime * sampleRate);
                const numSamples = endSample - startSample;
                
                // Create a new buffer for the trimmed audio
                const trimmedBuffer = audioContext.createBuffer(
                    audioBuffer.numberOfChannels,
                    numSamples,
                    sampleRate
                );
                
                // Copy the trimmed portion from each channel
                for (let channel = 0; channel < audioBuffer.numberOfChannels; channel++) {
                    const sourceData = audioBuffer.getChannelData(channel);
                    const trimmedData = trimmedBuffer.getChannelData(channel);
                    for (let i = 0; i < numSamples; i++) {
                        trimmedData[i] = sourceData[startSample + i];
                    }
                }
                
                // Convert the trimmed buffer back to a blob
                // We'll use WAV format for maximum compatibility
                const wavBlob = audioBufferToWav(trimmedBuffer);
                
                return wavBlob;
            }
            
            // Helper function to convert AudioBuffer to WAV blob
            function audioBufferToWav(buffer) {
                const numberOfChannels = buffer.numberOfChannels;
                const sampleRate = buffer.sampleRate;
                const format = 1; // PCM
                const bitDepth = 16;
                
                const bytesPerSample = bitDepth / 8;
                const blockAlign = numberOfChannels * bytesPerSample;
                
                const data = [];
                for (let i = 0; i < buffer.length; i++) {
                    for (let channel = 0; channel < numberOfChannels; channel++) {
                        const sample = buffer.getChannelData(channel)[i];
                        // Convert float to 16-bit PCM
                        const s = Math.max(-1, Math.min(1, sample));
                        data.push(s < 0 ? s * 0x8000 : s * 0x7FFF);
                    }
                }
                
                const dataLength = data.length * bytesPerSample;
                const bufferLength = 44 + dataLength;
                const arrayBuffer = new ArrayBuffer(bufferLength);
                const view = new DataView(arrayBuffer);
                
                // WAV header
                const writeString = (offset, string) => {
                    for (let i = 0; i < string.length; i++) {
                        view.setUint8(offset + i, string.charCodeAt(i));
                    }
                };
                
                writeString(0, 'RIFF');
                view.setUint32(4, 36 + dataLength, true);
                writeString(8, 'WAVE');
                writeString(12, 'fmt ');
                view.setUint32(16, 16, true); // fmt chunk size
                view.setUint16(20, format, true);
                view.setUint16(22, numberOfChannels, true);
                view.setUint32(24, sampleRate, true);
                view.setUint32(28, sampleRate * blockAlign, true);
                view.setUint16(32, blockAlign, true);
                view.setUint16(34, bitDepth, true);
                writeString(36, 'data');
                view.setUint32(40, dataLength, true);
                
                // Write PCM samples
                let offset = 44;
                for (let i = 0; i < data.length; i++) {
                    view.setInt16(offset, data[i], true);
                    offset += 2;
                }
                
                return new Blob([arrayBuffer], { type: 'audio/wav' });
            }

            function initTrimView() {
                if (!tempAudioBlob) {
                    console.error("initTrimView called, but tempAudioBlob is null.");
                    return;
                }
                showView('trim');

                // Use a timeout to ensure the view is visible and has dimensions
                setTimeout(() => {
                    if (wavesurfer) {
                        wavesurfer.destroy();
                    }
                    
                    console.log("Waveform container element:", waveformEl);
                    console.log("Container dimensions:", { 
                        width: waveformEl.clientWidth, 
                        height: waveformEl.clientHeight 
                    });

                    // 1. Initialize the Regions plugin first
                    const wsRegions = WaveSurfer.Regions.create();
                    let isProgrammaticRegion = false;

                    // This listener handles when the user creates a new region by dragging,
                    // ensuring only one region exists at a time.
                    wsRegions.on('region-created', (region) => {
                        if (isProgrammaticRegion) return;

                        // Clear any existing regions before setting the new one
                        wsRegions.clearRegions();
                        // Redraw the region and assign it to our tracking variable
                        trimRegion = wsRegions.addRegion({ 
                            ...region, 
                            color: 'rgba(255, 255, 255, 0.2)',
                            drag: true,
                            resize: true,
                        });
                    });

                    // 2. Create WaveSurfer instance, passing the plugin in the config
                    wavesurfer = WaveSurfer.create({
                        container: waveformEl,
                        waveColor: '#6366f1',
                        progressColor: '#4f46e5',
                        cursorColor: '#fff',
                        barWidth: 3,
                        barRadius: 3,
                        height: 'auto',
                        plugins: [wsRegions],
                    });

                    wavesurfer.on('error', (err) => console.error('WaveSurfer error:', err));

                    wavesurfer.on('ready', () => {
                        console.log("WaveSurfer is ready.");
                        // Use a flag to prevent the region-created event from causing an infinite loop
                        isProgrammaticRegion = true;
                        trimRegion = wsRegions.addRegion({
                            start: 0,
                            end: wavesurfer.getDuration(),
                            color: 'rgba(255, 255, 255, 0.2)',
                            drag: true,
                            resize: true,
                        });
                        isProgrammaticRegion = false;

                        wsRegions.on('region-out', (region) => {
                            wavesurfer.pause();

                            // reset cursor to start of region
                            wavesurfer.seekTo(region.start / wavesurfer.getDuration());

                            if (isTrimPlaying) {
                                wavesurfer.play();
                            }
                        });

                        trimRegion.element.children[0].style.width = '40px';
                        trimRegion.element.children[1].style.width = '40px';
                    });

                    wavesurfer.on('finish', () => {
                        // reset cursor to start of region
                        wavesurfer.seekTo(trimRegion.start / wavesurfer.getDuration());

                        if (isTrimPlaying) {
                            wavesurfer.play();
                        }
                    });

                    const audioUrl = URL.createObjectURL(tempAudioBlob);
                    console.log("Loading audio from URL:", audioUrl);
                    wavesurfer.load(audioUrl);
                }, 100); // A small delay of 100ms
            }

            // --- List View & Data Handling ---
            async function renderRecordingsList() {
                const transaction = db.transaction(STORE_NAME, 'readonly');
                const store = transaction.objectStore(STORE_NAME);
                const recordings = await new Promise(resolve => store.getAll().onsuccess = e => resolve(e.target.result));
                
                recordingsListEl.innerHTML = ''; // Clear list
                const emptyStateContainer = document.getElementById('empty-state-container');
                const storageInfoEl = document.getElementById('storage-info');
                const totalStorageEl = document.getElementById('total-storage');

                if (recordings.length === 0) {
                    if(emptyStateContainer) emptyStateContainer.style.display = 'flex';
                    recordingsListEl.style.display = 'none';
                    storageInfoEl.style.display = 'none';
                } else {
                    if(emptyStateContainer) emptyStateContainer.style.display = 'none';
                    recordingsListEl.style.display = 'block';
                    
                    // Calculate total storage size
                    let totalSize = 0;
                    recordings.forEach(rec => {
                        if (rec.blob) {
                            totalSize += rec.blob.size;
                        }
                    });
                    
                    // Display total storage
                    totalStorageEl.textContent = formatFileSize(totalSize);
                    storageInfoEl.style.display = 'block';
                    
                    recordings.reverse().forEach(rec => {
                        // Duration is now simply endTime since startTime is 0 for trimmed audio
                        const duration = rec.endTime;
                        const fileSize = rec.blob ? rec.blob.size : 0;
                        const listItem = document.createElement('div');
                        listItem.className = 'bg-gray-800 p-4 rounded-lg flex items-center justify-between cursor-pointer hover:bg-gray-700 transition-colors';
                        listItem.innerHTML = `
                            <div>
                                <h3 class="font-semibold text-lg">${rec.name}</h3>
                                <p class="text-sm text-gray-400">Duration: ${formatTime(duration)} • ${formatFileSize(fileSize)}</p>
                            </div>
                            <div class="flex items-center gap-2">
                                <button data-id="${rec.id}" class="rename-btn p-2 rounded-full hover:bg-blue-500/20 text-gray-400 hover:text-blue-400 transition-colors">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path></svg>
                                </button>
                                <button data-id="${rec.id}" class="delete-btn p-2 rounded-full hover:bg-red-500/20 text-gray-400 hover:text-red-400 transition-colors">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path><line x1="10" y1="11" x2="10" y2="17"></line><line x1="14" y1="11" x2="14" y2="17"></line></svg>
                                </button>
                            </div>
                        `;
                        const renameBtn = listItem.querySelector('.rename-btn');
                        renameBtn.addEventListener('click', (e) => {
                            e.stopPropagation();
                            recordingToRenameId = parseInt(renameBtn.dataset.id, 10);
                            renameMemoNameInput.value = rec.name;
                            renameModal.classList.remove('hidden');
                            renameModal.classList.add('flex');
                            renameMemoNameInput.focus();
                            renameMemoNameInput.select();
                        });

                        const deleteBtn = listItem.querySelector('.delete-btn');
                        deleteBtn.addEventListener('click', (e) => {
                            e.stopPropagation(); // Prevent the playRecording from firing
                            recordingToDeleteId = parseInt(deleteBtn.dataset.id, 10);
                            deleteModal.classList.remove('hidden');
                            deleteModal.classList.add('flex');
                        });

                        listItem.addEventListener('click', (e) => {
                            if (!e.target.closest('.delete-btn')) {
                                playRecording(rec.id);
                            }
                        });
                        recordingsListEl.appendChild(listItem);
                    });
                }
            }

            async function saveRecording(name, blob, startTime, endTime) {
                 const transaction = db.transaction(STORE_NAME, 'readwrite');
                 const store = transaction.objectStore(STORE_NAME);
                 store.add({ name, blob, startTime, endTime });
                 return new Promise(resolve => transaction.oncomplete = resolve);
            }

            async function deleteRecording(id) {
                const transaction = db.transaction(STORE_NAME, 'readwrite');
                const store = transaction.objectStore(STORE_NAME);
                store.delete(id);
                transaction.oncomplete = () => {
                    renderRecordingsList();
                    // Hide modal and reset ID after deletion
                    deleteModal.classList.add('hidden');
                    deleteModal.classList.remove('flex');
                    recordingToDeleteId = null;
                };
            }

            async function renameRecording(id, newName) {
                const transaction = db.transaction(STORE_NAME, 'readwrite');
                const store = transaction.objectStore(STORE_NAME);
                const request = store.get(id);
                request.onsuccess = (e) => {
                    const data = e.target.result;
                    data.name = newName;
                    const updateRequest = store.put(data);
                    updateRequest.onsuccess = () => {
                        renderRecordingsList();
                        // Hide modal and reset ID after renaming
                        renameModal.classList.add('hidden');
                        renameModal.classList.remove('flex');
                        recordingToRenameId = null;
                    };
                };
            }

            // --- Playback View ---
            async function playRecording(id) {
                const transaction = db.transaction(STORE_NAME, 'readonly');
                const store = transaction.objectStore(STORE_NAME);
                const recording = await new Promise(resolve => store.get(id).onsuccess = e => resolve(e.target.result));
                
                if (!recording) return;

                currentPlayingInfo = recording;
                if (currentPlayingAudio) {
                    URL.revokeObjectURL(currentPlayingAudio);
                }
                currentPlayingAudio = URL.createObjectURL(recording.blob);
                
                audioPlayer.src = currentPlayingAudio;
                playbackTitle.textContent = recording.name;
                
                audioPlayer.onloadedmetadata = () => {
                    // Since we're now saving trimmed audio, it always starts at 0
                    audioPlayer.currentTime = 0;
                    seekBar.max = audioPlayer.duration;
                    seekBar.min = 0;
                    totalTimeEl.textContent = formatTime(audioPlayer.duration);
                    audioPlayer.play();
                };
                
                showView('play');
            }
            
            function updatePlayPauseIcon(isPlaying) {
                 playPauseBtn.innerHTML = isPlaying
                    ? `<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="6" y="4" width="4" height="16"></rect><rect x="14" y="4" width="4" height="16"></rect></svg>`
                    : `<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="5 3 19 12 5 21 5 3"></polygon></svg>`;
            }

            function updatePlayPauseTrimIcon(isPlaying) {
                 playPauseTrimBtn.innerHTML = isPlaying
                    ? `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="6" y="4" width="4" height="16"></rect><rect x="14" y="4" width="4" height="16"></rect></svg>`
                    : `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="5 3 19 12 5 21 5 3"></polygon></svg>`;
            }

            function updateSeekBar() {
                if (!audioPlayer.paused) {
                    seekBar.value = audioPlayer.currentTime;
                    currentTimeEl.textContent = formatTime(audioPlayer.currentTime);
                    
                    // No need for custom loop logic since the audio is now trimmed
                    // The native loop attribute handles looping
                }
            }
            
            // --- Media Session API for lock screen controls ---
            function setupMediaSession() {
                if ('mediaSession' in navigator) {
                    navigator.mediaSession.metadata = new MediaMetadata({
                        title: currentPlayingInfo.name,
                        artist: 'EchoMemo',
                    });

                    navigator.mediaSession.setActionHandler('play', () => audioPlayer.play());
                    navigator.mediaSession.setActionHandler('pause', () => audioPlayer.pause());
                    navigator.mediaSession.setActionHandler('seekto', (details) => {
                        audioPlayer.currentTime = details.seekTime;
                    });
                }
            }
            
            // --- Utility ---
            function formatTime(seconds) {
                const min = Math.floor(seconds / 60);
                const sec = Math.floor(seconds % 60);
                return `${min}:${String(sec).padStart(2, '0')}`;
            }

            function formatFileSize(bytes) {
                if (bytes === 0) return '0 B';
                const k = 1024;
                const sizes = ['B', 'KB', 'MB', 'GB'];
                const i = Math.floor(Math.log(bytes) / Math.log(k));
                return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];
            }

            // --- Event Listeners ---
            recordNewBtn.addEventListener('click', prepareRecordingView);
            startRecordingBtn.addEventListener('click', startRecording);
            stopRecordingBtn.addEventListener('click', stopRecording);
            
            cancelRecordBtn.addEventListener('click', () => {
                showView('list');
            });

            cancelTrimBtn.addEventListener('click', () => {
                tempAudioBlob = null;
                if (isTrimPlaying) {
                    wavesurfer.pause();
                    isTrimPlaying = false;
                }
                if(wavesurfer) wavesurfer.destroy();
                showView('list');
                updatePlayPauseTrimIcon(false);
            });

            playPauseTrimBtn.addEventListener('click', () => {
                if (!wavesurfer || !trimRegion) return;
                if (isTrimPlaying) {
                    isTrimPlaying = false;
                    wavesurfer.stop();
                } else {
                    isTrimPlaying = true;
                    wavesurfer.seekTo(trimRegion.start / wavesurfer.getDuration());
                    wavesurfer.play();
                }
                updatePlayPauseTrimIcon(isTrimPlaying);
            });

            saveTrimBtn.addEventListener('click', () => {
                if (isTrimPlaying) {
                    wavesurfer.pause();
                    isTrimPlaying = false;
                    updatePlayPauseTrimIcon(false);
                }
                if (!trimRegion) {
                    console.warn('Save clicked, but no trim region is selected.');
                    // Add a visual shake effect to the button as feedback
                    saveTrimBtn.classList.add('animate-head-shake');
                    setTimeout(() => saveTrimBtn.classList.remove('animate-head-shake'), 500);
                    return;
                }
                waveformEl.style.display = 'none'; // Hide waveform
                saveModal.classList.remove('hidden');
                saveModal.classList.add('flex');
                memoNameInput.value = `Memo ${new Date().toLocaleString()}`;
                memoNameInput.focus();
                memoNameInput.select();
            });
            
            cancelSaveBtn.addEventListener('click', () => {
                saveModal.classList.add('hidden');
                saveModal.classList.remove('flex');
                waveformEl.style.display = 'block'; // Show waveform again
            });

            confirmSaveBtn.addEventListener('click', async () => {
                const name = memoNameInput.value.trim();
                if (!name) {
                    // Replaced alert with a visual indicator for better UX
                    memoNameInput.classList.add('ring-2', 'ring-red-500');
                    setTimeout(() => memoNameInput.classList.remove('ring-2', 'ring-red-500'), 2000);
                    return;
                }
                
                const startTime = trimRegion.start;
                const endTime = trimRegion.end;

                // Actually trim the audio blob using Web Audio API
                const trimmedBlob = await trimAudioBlob(tempAudioBlob, startTime, endTime);

                // Save with 0 as start since we're saving the trimmed audio
                await saveRecording(name, trimmedBlob, 0, endTime - startTime);

                saveModal.classList.add('hidden');
                saveModal.classList.remove('flex');
                tempAudioBlob = null;
                if(wavesurfer) wavesurfer.destroy();
                waveformEl.style.display = 'block'; // Reset for next time

                await renderRecordingsList();
                showView('list');
            });

            confirmDeleteBtn.addEventListener('click', () => {
                if (recordingToDeleteId !== null) {
                    deleteRecording(recordingToDeleteId);
                }
            });

            cancelDeleteBtn.addEventListener('click', () => {
                deleteModal.classList.add('hidden');
                deleteModal.classList.remove('flex');
                recordingToDeleteId = null;
            });

            confirmRenameBtn.addEventListener('click', () => {
                const newName = renameMemoNameInput.value.trim();
                if (newName && recordingToRenameId !== null) {
                    renameRecording(recordingToRenameId, newName);
                }
            });

            cancelRenameBtn.addEventListener('click', () => {
                renameModal.classList.add('hidden');
                renameModal.classList.remove('flex');
                recordingToRenameId = null;
            });

            playPauseBtn.addEventListener('click', () => {
                if (audioPlayer.paused) audioPlayer.play();
                else audioPlayer.pause();
            });
            
            audioPlayer.addEventListener('play', () => {
                updatePlayPauseIcon(true);
                setupMediaSession();
            });
            audioPlayer.addEventListener('pause', () => updatePlayPauseIcon(false));
            audioPlayer.addEventListener('timeupdate', updateSeekBar);
            
            seekBar.addEventListener('input', () => {
                audioPlayer.currentTime = seekBar.value;
            });
            
            backToListBtn.addEventListener('click', () => {
                audioPlayer.pause();
                audioPlayer.src = '';
                if(currentPlayingAudio) URL.revokeObjectURL(currentPlayingAudio);
                currentPlayingAudio = null;
                currentPlayingInfo = null;
                showView('list');
            });
            
            // --- Playlist View Functions ---
            async function renderPlaylistView() {
                const transaction = db.transaction(STORE_NAME, 'readonly');
                const store = transaction.objectStore(STORE_NAME);
                const recordings = await new Promise(resolve => store.getAll().onsuccess = e => resolve(e.target.result));
                
                playlistItemsContainer.innerHTML = '';
                
                if (recordings.length === 0) {
                    playlistEmptyState.style.display = 'flex';
                    playlistItemsContainer.style.display = 'none';
                    startPlaylistBtn.disabled = true;
                } else {
                    playlistEmptyState.style.display = 'none';
                    playlistItemsContainer.style.display = 'block';
                    
                    const defaultRepeats = parseInt(defaultRepeatsInput.value) || 3;
                    
                    recordings.forEach(rec => {
                        const duration = rec.endTime;
                        const item = document.createElement('div');
                        item.className = 'bg-gray-800 p-3 rounded-lg flex items-center gap-3 cursor-pointer hover:bg-gray-700 transition-colors';
                        item.innerHTML = `
                            <input type="checkbox" class="playlist-checkbox w-5 h-5 rounded border-gray-600 bg-gray-700 text-indigo-600 focus:ring-2 focus:ring-indigo-500 pointer-events-none" data-id="${rec.id}">
                            <div class="flex-grow pointer-events-none">
                                <h3 class="font-semibold">${rec.name}</h3>
                                <p class="text-sm text-gray-400">Duration: ${formatTime(duration)}</p>
                            </div>
                            <div class="flex items-center gap-2">
                                <label class="text-sm text-gray-400 pointer-events-none">×</label>
                                <input type="number" class="playlist-repeats w-16 bg-gray-700 text-white rounded-md px-2 py-1 text-center border border-gray-600 focus:ring-2 focus:ring-indigo-500 focus:outline-none pointer-events-auto" value="${defaultRepeats}" min="1" max="99" data-id="${rec.id}">
                            </div>
                        `;
                        
                        // Make the entire row clickable to toggle checkbox
                        item.addEventListener('click', (e) => {
                            // Don't toggle if clicking on the number input
                            if (e.target.classList.contains('playlist-repeats')) {
                                return;
                            }
                            const checkbox = item.querySelector('.playlist-checkbox');
                            checkbox.checked = !checkbox.checked;
                            updateStartPlaylistButton();
                        });
                        
                        playlistItemsContainer.appendChild(item);
                    });
                    
                    updateStartPlaylistButton();
                }
            }
            
            function updateStartPlaylistButton() {
                const checkedBoxes = playlistItemsContainer.querySelectorAll('.playlist-checkbox:checked');
                startPlaylistBtn.disabled = checkedBoxes.length === 0;
            }
            
            async function startPlaylist() {
                // Gather selected items
                const checkedBoxes = playlistItemsContainer.querySelectorAll('.playlist-checkbox:checked');
                if (checkedBoxes.length === 0) return;
                
                playlistItems = [];
                const transaction = db.transaction(STORE_NAME, 'readonly');
                const store = transaction.objectStore(STORE_NAME);
                
                for (const checkbox of checkedBoxes) {
                    const id = parseInt(checkbox.dataset.id);
                    const repeatsInput = playlistItemsContainer.querySelector(`.playlist-repeats[data-id="${id}"]`);
                    const repeats = parseInt(repeatsInput.value) || 1;
                    
                    const recording = await new Promise(resolve => store.get(id).onsuccess = e => resolve(e.target.result));
                    if (recording) {
                        playlistItems.push({
                            id: recording.id,
                            name: recording.name,
                            repeats: repeats,
                            blob: recording.blob,
                            duration: recording.endTime
                        });
                    }
                }
                
                if (playlistItems.length === 0) return;
                
                // Start playback
                currentPlaylistIndex = 0;
                currentRepeatCount = 0;
                showView('playlistPlayback');
                playNextInPlaylist();
            }
            
            function playNextInPlaylist() {
                if (playlistItems.length === 0) return;
                
                const currentItem = playlistItems[currentPlaylistIndex];
                
                // Update UI
                playlistCurrentTitle.textContent = currentItem.name;
                playlistProgressText.textContent = `Entry ${currentPlaylistIndex + 1} of ${playlistItems.length} • Repeat ${currentRepeatCount + 1} of ${currentItem.repeats}`;
                
                // Set up audio
                const audioUrl = URL.createObjectURL(currentItem.blob);
                playlistAudioPlayer.src = audioUrl;
                
                playlistAudioPlayer.onloadedmetadata = () => {
                    playlistSeekBar.max = playlistAudioPlayer.duration;
                    playlistSeekBar.min = 0;
                    playlistTotalTime.textContent = formatTime(playlistAudioPlayer.duration);
                    playlistAudioPlayer.play();
                    isPlaylistPlaying = true;
                    updatePlaylistPlayPauseIcon(true);
                    setupPlaylistMediaSession();
                };
                
                playlistAudioPlayer.onended = () => {
                    URL.revokeObjectURL(audioUrl);
                    currentRepeatCount++;
                    
                    // Check if we need to repeat this entry
                    if (currentRepeatCount < currentItem.repeats) {
                        playNextInPlaylist();
                    } else {
                        // Move to next entry
                        currentRepeatCount = 0;
                        currentPlaylistIndex++;
                        
                        // Loop back to start if at the end
                        if (currentPlaylistIndex >= playlistItems.length) {
                            currentPlaylistIndex = 0;
                        }
                        
                        playNextInPlaylist();
                    }
                };
            }
            
            // --- Media Session API for playlist lock screen controls ---
            function setupPlaylistMediaSession() {
                if ('mediaSession' in navigator && playlistItems.length > 0) {
                    const currentItem = playlistItems[currentPlaylistIndex];
                    navigator.mediaSession.metadata = new MediaMetadata({
                        title: currentItem.name,
                        artist: 'EchoMemo Playlist',
                        album: `Entry ${currentPlaylistIndex + 1} of ${playlistItems.length}`,
                    });

                    navigator.mediaSession.setActionHandler('play', () => {
                        playlistAudioPlayer.play();
                        isPlaylistPlaying = true;
                    });
                    navigator.mediaSession.setActionHandler('pause', () => {
                        playlistAudioPlayer.pause();
                        isPlaylistPlaying = false;
                    });
                    navigator.mediaSession.setActionHandler('seekto', (details) => {
                        if (details.seekTime !== undefined) {
                            playlistAudioPlayer.currentTime = details.seekTime;
                        }
                    });
                    
                    // Optional: Add next/previous track handlers
                    navigator.mediaSession.setActionHandler('nexttrack', () => {
                        // Skip to next entry
                        currentRepeatCount = 0;
                        currentPlaylistIndex++;
                        if (currentPlaylistIndex >= playlistItems.length) {
                            currentPlaylistIndex = 0;
                        }
                        playlistAudioPlayer.pause();
                        playNextInPlaylist();
                    });
                    
                    navigator.mediaSession.setActionHandler('previoustrack', () => {
                        // Go to previous entry
                        currentRepeatCount = 0;
                        currentPlaylistIndex--;
                        if (currentPlaylistIndex < 0) {
                            currentPlaylistIndex = playlistItems.length - 1;
                        }
                        playlistAudioPlayer.pause();
                        playNextInPlaylist();
                    });
                }
            }
            
            function updatePlaylistPlayPauseIcon(isPlaying) {
                playlistPlayPauseBtn.innerHTML = isPlaying
                    ? `<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="6" y="4" width="4" height="16"></rect><rect x="14" y="4" width="4" height="16"></rect></svg>`
                    : `<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="5 3 19 12 5 21 5 3"></polygon></svg>`;
            }
            
            function updatePlaylistSeekBar() {
                if (!playlistAudioPlayer.paused) {
                    playlistSeekBar.value = playlistAudioPlayer.currentTime;
                    playlistCurrentTime.textContent = formatTime(playlistAudioPlayer.currentTime);
                }
            }
            
            // --- Playlist Event Listeners ---
            openPlaylistBtn.addEventListener('click', async () => {
                await renderPlaylistView();
                showView('playlist');
            });
            
            backFromPlaylistBtn.addEventListener('click', () => {
                showView('list');
            });
            
            defaultRepeatsInput.addEventListener('input', () => {
                // Update all repeat inputs when default changes
                const repeatsInputs = playlistItemsContainer.querySelectorAll('.playlist-repeats');
                const newValue = defaultRepeatsInput.value;
                repeatsInputs.forEach(input => {
                    input.value = newValue;
                });
            });
            
            selectAllBtn.addEventListener('click', () => {
                const checkboxes = playlistItemsContainer.querySelectorAll('.playlist-checkbox');
                const allChecked = Array.from(checkboxes).every(cb => cb.checked);
                
                checkboxes.forEach(cb => {
                    cb.checked = !allChecked;
                });
                
                selectAllBtn.textContent = allChecked ? 'Select All' : 'Deselect All';
                updateStartPlaylistButton();
            });
            
            startPlaylistBtn.addEventListener('click', startPlaylist);
            
            stopPlaylistBtn.addEventListener('click', () => {
                playlistAudioPlayer.pause();
                playlistAudioPlayer.src = '';
                isPlaylistPlaying = false;
                playlistItems = [];
                currentPlaylistIndex = 0;
                currentRepeatCount = 0;
                showView('list');
            });
            
            playlistPlayPauseBtn.addEventListener('click', () => {
                if (playlistAudioPlayer.paused) {
                    playlistAudioPlayer.play();
                    isPlaylistPlaying = true;
                } else {
                    playlistAudioPlayer.pause();
                    isPlaylistPlaying = false;
                }
            });
            
            playlistAudioPlayer.addEventListener('play', () => {
                updatePlaylistPlayPauseIcon(true);
            });
            
            playlistAudioPlayer.addEventListener('pause', () => {
                updatePlaylistPlayPauseIcon(false);
            });
            
            playlistAudioPlayer.addEventListener('timeupdate', updatePlaylistSeekBar);
            
            playlistSeekBar.addEventListener('input', () => {
                playlistAudioPlayer.currentTime = playlistSeekBar.value;
            });

            // --- PWA Installation ---
            let deferredPrompt;
            const installButton = document.getElementById('install-button');

            // Detect if user is on iOS
            function isIOS() {
                return /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
            }

            // Detect if app is already installed (standalone mode)
            function isInStandaloneMode() {
                return (window.matchMedia('(display-mode: standalone)').matches) || (window.navigator.standalone);
            }

            // Show install instructions for iOS
            function showIOSInstallInstructions() {
                // Create modal overlay
                const modal = document.createElement('div');
                modal.className = 'fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50 p-4';
                modal.innerHTML = `
                    <div class="bg-gray-800 rounded-lg p-6 max-w-sm w-full border border-gray-700">
                        <h3 class="text-xl font-bold mb-4 text-white">Install EchoMemo</h3>
                        <p class="text-gray-300 mb-4">To install this app on your iPhone:</p>
                        <ol class="list-decimal list-inside space-y-2 text-gray-300 mb-6">
                            <li>Tap the <strong>Share</strong> button <svg class="inline w-5 h-5" fill="currentColor" viewBox="0 0 24 24"><path d="M18 16c-.8 0-1.5.3-2 .8l-7.1-4.2c.1-.2.1-.5.1-.8 0-.3 0-.5-.1-.8L16 6.8c.5.5 1.2.8 2 .8 1.7 0 3-1.3 3-3s-1.3-3-3-3-3 1.3-3 3c0 .3 0 .5.1.8L8 9.6C7.5 9.1 6.8 8.8 6 8.8c-1.7 0-3 1.3-3 3s1.3 3 3 3c.8 0 1.5-.3 2-.8l7.1 4.2c-.1.2-.1.5-.1.8 0 1.7 1.3 3 3 3s3-1.3 3-3-1.3-3-3-3z"/></svg> in Safari</li>
                            <li>Scroll down and tap <strong>"Add to Home Screen"</strong></li>
                            <li>Tap <strong>Add</strong> in the top right corner</li>
                        </ol>
                        <button id="close-ios-modal" class="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-4 rounded-lg transition-colors">
                            Got it!
                        </button>
                    </div>
                `;
                document.body.appendChild(modal);

                // Close modal when clicking button or outside
                document.getElementById('close-ios-modal').addEventListener('click', () => {
                    modal.remove();
                });
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) {
                        modal.remove();
                    }
                });
            }

            // Show install button for iOS if not already installed
            if (isIOS() && !isInStandaloneMode()) {
                installButton.classList.remove('hidden');
            }

            // For Android and other platforms that support beforeinstallprompt
            window.addEventListener('beforeinstallprompt', (e) => {
                e.preventDefault();
                deferredPrompt = e;
                installButton.classList.remove('hidden');
            });

            installButton.addEventListener('click', async () => {
                // If iOS, show instructions
                if (isIOS()) {
                    showIOSInstallInstructions();
                    return;
                }

                // For other platforms, use the native install prompt
                if (deferredPrompt) {
                    deferredPrompt.prompt();
                    const { outcome } = await deferredPrompt.userChoice;
                    console.log(`User response to the install prompt: ${outcome}`);
                    deferredPrompt = null;
                    installButton.classList.add('hidden');
                }
            });

            window.addEventListener('appinstalled', () => {
                installButton.classList.add('hidden');
                deferredPrompt = null;
                console.log('PWA was installed');
            });

            // --- App Initialization ---
            async function main() {
                await initDB();
                await renderRecordingsList();
                showView('list');
                updatePlayPauseIcon(false); // Initial state
            }
            main();

        }); // End DOMContentLoaded
    </script>
    
    <!-- Service Worker Registration -->
    <script>
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('./sw.js').then(registration => {
                    console.log('ServiceWorker registration successful with scope: ', registration.scope);
                }, err => {
                    console.log('ServiceWorker registration failed: ', err);
                });
            });
        }
    </script>
</body>
</html>


